#java多线程编程      具体内容查看threadInfo包，-----2020-12-30
    最早的时候DOS系统有一个特点，只要电脑有病毒，那么电脑就死机了，即：在同一时间段内只允许有一个进程，
    而后来到了我们windows时代电脑即使有病毒也能正常使用。但是会变慢，因为在一个CPU、一块资源的情况下，
    程序利用一些轮转的方法，可以让一个资源在一个时间段上同时处理不同的程序，但是在一个时间点上只允许一个
    进程去执行。
    
    在我们每一个进程上可以划分出若干个线程，所以多线程的操作一定要快于多进程的操作，但是所有的线程一定
    要在进程的基础上进行划分。所以进程消失线程也就消失了。
     
     
#实现JAVA多线程的操作******
    在JAVA多线程的实现一个要有个线程的主类，而这个线程主类往往是需要操作一些资源，但是对于这个子类多线程主线是
    的实现是由要求的。
        ·继承Thread父类
        ·实现Runable接口（Callable接口）
     
    #继承Thread
        java.lang.Thread中，子类继承Thread之后，需要覆写run方法，属于线程的主方法，
    实现线程的主体类：

#思考：为什么现在启动多线程不使用run()方法，而非要使用start()方法呢？
    为了方便解释此问题，必须打开Thred类的strat()方法来看。
    private native void start0();方法交由JVM来实现，所以只有Tread的strat()方法才能启动多线程。
     
#实现Runnable接口
    继承Thread类会产生单继承的局限操作，最好的做法是使用接口来解决问题，最好使用我们的runnable来实现接口，
    首先我们来观察下Runnable接口的定义结构：
        @FunctionalInterface 函数式接口。可以利用Lamda表达式。或者方法引用。
        
    如果要启动多线程，只能依靠Thread()类中的strar()方法，在之前继承Thread类的

#两种线程实现方式的区别
    对于多线程的两种实现模式，一个是继承Thread类，一个是实现Runnable接口，本质上讲要用Runable来实现，这也
    可以避免单继承局限，但是除了这也的使用原则之外，还需要清楚2种实现方法的联系。
        首先来观察Thread类的定义结构：
            public class Thread implements Runnable；可以发现Thread类实现了Runnable接口，
        通过可以发现，整个代码使用的就是代理模式，但是与传统的代理模式又有些差别。如果按照传说设计模式，
        想要启动多线程，理论上是调用run方法。实际调用的是start方法，
        
        除了以上的继承关联之外 还有一个区别，Runable接口实现的多线程要比Thread实现的多线程更方便的表示出数据共享的概率。
        
    范例：希望有三个线程进行卖票--Thread实现
    
#面试题：请解释多线程的两种实现方式以及区别？
    ·多线程需要一个线程主类，这个类要么继承Thread类，要么实现Runnable接口。
    ·用我们的Runnable接口可以比Thread类更好的实现数据共享的操作，并且利用Runnable接口可以避免单继承局限。
    
#实现Callable接口
    从JDK1.5之后对于多线程的多了一个Callable接口，在这个接口里面比我们Runnable强大，唯一在于可以返回执行返回结果。
    Class FutureTask<V>~~~~