#Synchronized详解
    - 对象锁----SynDemo1
        包括方法锁（默认锁对象为this，当前实例对象）和同步代码块锁（自己指定锁对象）
    1、代码块形式：手动指定锁定对象，也可以是this，也可以是自定义的锁
    
    - 方法锁形式：synchronized修饰普通方法，锁对象默认为this --- SynDemo3
    
    二:类锁
        指synchronized 修饰静态方法或指定锁对象为Class对象
    1、synchroized修饰静态方法  -----------SynDemo4
    2、synchroized指定锁对象为Class对象 -----------SynDemo5
    
#思考
    1、两个线程同时访问一个对象的同步方法
    2、两个线程同时访问2个对象的同步方法
    3、两个线程访问的是synchroized静态方法
    4、两个线程同时访问同步（被synchroized）和非同步（未被synchroized修饰）的方法
    5、两个线程同时访问1个对象的不同的普通同步方法
    6、两个线程同时访问一个静态的synchroized方法和非静态的synchroized方法
    7、方法抛出异常后，会释锁吗
    
#核心思想
    1、一把锁只能同时被一个线程获取，没有难道的锁线程只能等待
    2、每个实例都对应有自己的一把锁（this）,不同实例之间互不影响，例外：锁对象的*.class以及synchroized修饰的
        是static方法的时候，所有对象公用同一锁。
    3、synchroized修饰的方法，无论方法正常执行完毕还是抛出异常，都会释放锁。
    
#synchroized的性质
    1、可重入性
    概念：指同一个线程外层函数获取到锁之后，内层函数可以直接使用该锁
    好处：避免死锁，提升封装性（如果不可重入，假设method1拿到锁之后，在method1中又调用了method2，如果method2没办法
        使用method1拿到的锁，那么method2将一直等待，但是method1由于未执行完毕，又无法释放锁，就导致了死锁，可重入
        正好避免这种情况）
    粒度：线程而非调用（用3中情况来说明与pthread的区别）
        - 情况1：证明同一个方法是可重入的（递归）------------SynDemo6.java
        - 情况2：证明可重入不要求是同一个方法 ------------SynDemo8.java
        - 情况3：证明可重入不要求是同一个类 ------------SynDemo9.java
        
    2、不可中断性
    概念：如果这个锁被B线程获取，如果A线程想要获取这把锁，只能选择等待或者阻塞，直到B线程释放这把锁，如果B线程一直不
        释放这把锁，那么A线程将一直等待。
    相比之下，未来的LOCK类，可以拥有中断的能力，（如果一个线程等待锁的时间太长，有权利中断当前已经获取锁的线程的执行，也可以推出等待）
    
#深入原理
    1、加锁和释放锁的原理：现象、时机（内置锁this），深入JVM看字节码（反编译看monitor指令）------SynDemo10.java
    2、深入JVM看字节码，创建如下的代码-------SynDemo11.java

        
    