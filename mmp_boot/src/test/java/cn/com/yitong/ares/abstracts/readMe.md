#---**********************--------抽象类
#====抽象类的基本概念
        如果说现在在一个类之中需要定义一个没有方法体的方法，那么可以利用abstract关键字来进行定义，
    包含抽象方法的类就可以使用abstract来定义成抽象类。
        类的核心组成：属性，方法，但是我们在学习完继承操作之后，会发现子类存在有一种覆写父类方法的机制，而且这一机制直接与我们多对象的多态性有关，
    于是这样就会出现一个问题，加入现在使用的是普通类，并且在这个类里面有个print()方法，
    public class A {    
        private void pring(){
            System.out.println("AAAAAAAAAAAAAAA");
        }
    }
        但是这个A类在设计之初有要求，希望继承他的子类一定要继承这个print()方法，但事实上这个时候的子类完全可以灵活选择是否继承这个pring()方法。
    但是由于只是一个普通方法，所有对于子类的覆写没有任何要求，于是这样就会出现一个漏洞，父类无法强制要求子类覆写方法。
        如果只依靠我们普通类的继承，那么就不能堆子类产生限制，所有我们可以利用抽象类，抽象方法来解除此问题。
#范例：定义抽象类
        public abstract class A {
            public void fun(){
                this.pring();
            }
            public abstract void pring();//没有方法体，使用abstract声明
        }
        抽象方法的特点： 一个是使用abstract来声明，一个是方法后面没有大括号{}，表示没有方法体。
#范例：错误的使用抽象方法
         public static void main(String[] args) {
            A a = new A();
         }
         本处直接使用了关键字new，实例化了对象A,编译报错，抽象类不能够直接对象实例化操作的。因为一旦类的对象实例化了，
     意味着可以直接调用类里面的方法，但是抽象方法只是一个声明，并没有具体的方法体。所以在实际的开发之中，使用原则。
          ·抽象类必须要有子类，子类可以利用extends来继承抽象类，一个子类只能继承一个父类
          ·抽象类的子类如果不是抽象类，那么必须要覆写抽象类中的全部抽象方法。
          ·抽象类可以利用的向上转型机制，通过子类对象进行实例化操作。
     抽象类与普通类相比最大的好处是强制定义了子类的实现要求。
     本质上讲抽象类只是比普通类多了一些抽象的方法定义而已。
        在实际的设计之中，父类的设计最重要，普通类与抽象类相比，明细抽象类的约束设计更加严格，
     在开发之中，不会几乎出现普通子类的定义情况，大多数都是继承抽象类。
    
 #抽象的相关说明
        1、抽象类不能使用final关键字类定义，因为抽象类必须要有子类，而final不能有子类。
        2、抽象类就是比普通类多了抽象方法而已，但是普通类中的所有结构，抽象类中都可以定义，包括普通方法，属性，常量等，
        而且子类对像也符合我们的对象实例化流程，默认先调用父类构造方法，而后在执行子类自己的构造。
        3、抽象类中可以没有抽象方法，但是依然不可能用关键字new进行实例化操作。
        4、外部抽象类上不允许使用static声明，但是内部抽象内可以使用static声明，这样表明是一个外部抽象类。
        5、抽象类中可以存在static方法，而且static方法不受实例化的控制。
        
#抽象类的实际应用 ---- 模板设计模式
        清楚了抽象类的产生动机以及抽象类的使用之后，下面我们就必须搞清楚一个问题，抽象类与普通类有什么区别？
        现在假设有3个物种：
            ·机器人：补充能量 + 工作
            ·人：吃饭 + 工作 + 睡觉
            ·猪：吃饭 + 睡觉
        现在要求实现一种命令的模式，不管是何种物种，只要传递指定的指令就可以进行操作。
        



































